grp.lat = cut(lat, 3, labels = FALSE)
grp.lon = cut(lon, 3, labels = FALSE)
})
head(df2)
df2 <- within(df, {
grp.lat = cut(V1, 3, labels = FALSE)
grp.lon = cut(V2, 3, labels = FALSE)
})
head(df2)
View(df2)
start_grp1_lon <- min(df2$lon[df2$grp.lon==1])
start_grp2_lon <- min(df2$lon[df2$grp.lon==2])
start_grp3_lon <- min(df2$lon[df2$grp.lon==3])
start_grp1_lat <- min(df2$lat[df2$grp.lat==1])
start_grp2_lat <- min(df2$lat[df2$grp.lat==2])
start_grp3_lat <- min(df2$lat[df2$grp.lat==3])
plot(lat ~ lon, data = df2, pch = (15:23)[grp.lon*grp.lat], col=[grp.lon]) #pch = (15:17)[grp.lon], col = grp.lat)
abline(v = c(start_grp1_lon, start_grp2_lon, start_grp3_lon))
abline(h = c(start_grp1_lat, start_grp2_lat, start_grp3_lat))
start_grp1_lon <- min(df2$lon[df2$grp.lon==1])
start_grp2_lon <- min(df2$lon[df2$grp.lon==2])
start_grp3_lon <- min(df2$lon[df2$grp.lon==3])
start_grp1_lat <- min(df2$lat[df2$grp.lat==1])
start_grp2_lat <- min(df2$lat[df2$grp.lat==2])
start_grp3_lat <- min(df2$lat[df2$grp.lat==3])
plot(lat ~ lon, data = df2, pch = (15:23)[grp.lon*grp.lat], col=[grp.lon]) #pch = (15:17)[grp.lon], col = grp.lat)
abline(v = c(start_grp1_lon, start_grp2_lon, start_grp3_lon))
abline(h = c(start_grp1_lat, start_grp2_lat, start_grp3_lat))
colnames(df2$V1 = "lon")
colnames(df2$V1) = "lon"
colnames(df2) = c("lon", "lat")
colnames(df2)[1:2] = c("lon", "lat")
start_grp1_lon <- min(df2$lon[df2$grp.lon==1])
start_grp2_lon <- min(df2$lon[df2$grp.lon==2])
start_grp3_lon <- min(df2$lon[df2$grp.lon==3])
start_grp1_lat <- min(df2$lat[df2$grp.lat==1])
start_grp2_lat <- min(df2$lat[df2$grp.lat==2])
start_grp3_lat <- min(df2$lat[df2$grp.lat==3])
plot(lat ~ lon, data = df2, pch = (15:23)[grp.lon*grp.lat], col=[grp.lon]) #pch = (15:17)[grp.lon], col = grp.lat)
abline(v = c(start_grp1_lon, start_grp2_lon, start_grp3_lon))
abline(h = c(start_grp1_lat, start_grp2_lat, start_grp3_lat))
start_grp1_lon <- min(df2$lon[df2$grp.lon==1])
start_grp2_lon <- min(df2$lon[df2$grp.lon==2])
start_grp3_lon <- min(df2$lon[df2$grp.lon==3])
start_grp1_lat <- min(df2$lat[df2$grp.lat==1])
start_grp2_lat <- min(df2$lat[df2$grp.lat==2])
start_grp3_lat <- min(df2$lat[df2$grp.lat==3])
plot(lat ~ lon, data = df2)
abline(v = c(start_grp1_lon, start_grp2_lon, start_grp3_lon))
abline(h = c(start_grp1_lat, start_grp2_lat, start_grp3_lat))
df <- structure(list(LAT = c(35.61226, 35.34986, 35.17794, 34.60425,34.40356, 33.94433, 33.41834, 16.89566, 16.89561, 16.89561),
LON = c(-9.604802, -9.803048, -9.921968, -10.30782, -10.44971,-10.76656, -11.13053, -24.99776, -24.99788, -24.99773)),
.Names = c("LAT","LON"), class = "data.frame", row.names = c(1L, 2L, 3L, 4L, 5L,6L, 7L, 44161L, 44162L, 44163L))
View(df)
library(sp)
dfSp <- SpatialPointsDataFrame(matrix(c(df$LON, df$LAT), nrow = nrow(df)), data = df)
View(dfSp)
grid <- makegrid(dfSp, n = 20)
gridSp <- SpatialPointsDataFrame(grid, data = data.frame(id = rownames(grid)))
View(grid)
library(raster)
gridSpRas <- rasterFromXYZ(gridSp)
gridPoly <- rasterToPolygons(gridSpRas, dissolve = T)
install.packages("raster")
library(raster)
gridSpRas <- rasterFromXYZ(gridSp)
gridPoly <- rasterToPolygons(gridSpRas, dissolve = T)
plot(gridPoly)
points(dfSp, col = "red", pch = "+")
gridPoly$count <- unlist(lapply(1:length(gridPoly),
function (x) {length(dfSp[gridPoly[x, ], ])}))
spplot(gridPoly, zcol = "count")
load("~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Cleaned_data/GeoAccidentalidad.RData")
GeoAccidentalidad <- na.omit(GeoAccidentalidad)
install.packages(c("e1071", "ggmap", "gplots", "lme4", "pamr", "purrr", "TH.data"))
install.packages("ggvoronoi")
library(ggvoronoi)
set.seed(45056)
x <- sample(1:200,100)
y <- sample(1:200,100)
points <- data.frame(x, y,
distance = sqrt((x-100)^2 + (y-100)^2))
circle <- data.frame(x = 100*(1+cos(seq(0, 2*pi, length.out = 2500))),
y = 100*(1+sin(seq(0, 2*pi, length.out = 2500))),
group = rep(1,2500))
ggplot(points) +
geom_point(aes(x,y,color=distance)) +
geom_path(data=circle,aes(x,y,group=group))
library(ggplot2)
library(ggvoronoi)
set.seed(45056)
x <- sample(1:200,100)
y <- sample(1:200,100)
points <- data.frame(x, y,
distance = sqrt((x-100)^2 + (y-100)^2))
circle <- data.frame(x = 100*(1+cos(seq(0, 2*pi, length.out = 2500))),
y = 100*(1+sin(seq(0, 2*pi, length.out = 2500))),
group = rep(1,2500))
ggplot(points) +
geom_point(aes(x,y,color=distance)) +
geom_path(data=circle,aes(x,y,group=group))
View(points)
ggplot(points) +
geom_voronoi(aes(x,y,fill=distance))
ggvoronoi
help(ggvoronoi)
vignette("ggvoronoi")
install.packages("ggvoronoi")
remotes::install_github("garretrc/ggvoronoi", dependencies = TRUE, build_opts = c("--no-resave-data"))
cl
cl()
df <- data.frame(GeoAccidentalidad$lat, GeoAccidentalidad$lon)
df <- df[1:1000,]
library(sp)
coordinates(sp) <- ~ lon + lat
coordinates(df) <- ~ lon + lat
View(df)
colnames(df) <- c("lon", "lat")
coordinates(df) <- ~ lon + lat
class(df)
df
View(df)
min(df$lon)
min(df$lat)
max(df$lat)
voronoipolygons = function(layer) {
require(deldir)
crds = layer@coords
z = deldir(crds[,1], crds[,2])
w = tile.list(z)
polys = vector(mode='list', length=length(w))
require(sp)
for (i in seq(along=polys)) {
pcrds = cbind(w[[i]]$x, w[[i]]$y)
pcrds = rbind(pcrds, pcrds[1,])
polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i))
}
SP = SpatialPolygons(polys)
voronoi = SpatialPolygonsDataFrame(SP, data=data.frame(dummy = seq(length(SP)), row.names=sapply(slot(SP, 'polygons'),
function(x) slot(x, 'ID'))))
}
vp <- voronoipolygons(df[1:10,])
plot(vp)
df[1:10,]
vp <- voronoipolygons(df)
plot(vp)
df[1:10,]
df <- unique(df)
vp <- voronoipolygons(df[1:10,])
plot(vp)
class(df)
proj4string(india)
proj4string(df)
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
View(df)
proj4string(df)
df <- data.frame(GeoAccidentalidad$lat, GeoAccidentalidad$lon)
df <- unique(df[1:1000,]
)
colnames(df) <- c("lon", "lat")
coordinates(df) <- ~ lon + lat
View(df)
View(df)
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
View(df)
View(df)
vp <- voronoipolygons(df[1:10,])
plot(vp)
vp <- voronoipolygons(GeoAccidentalidad)
plot(df)
over(vp,df)
proj4string(vp)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
proj4string(vp)
over(vp,df)
View(GeoAccidentalidad)
df
random(df)
spsample(df, 5)
spsample(df, 5, type = "random")
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
plot(vp)
proj4string(vp)
over(vp, df)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
over(vp, df)
View(GeoAccidentalidad)
View(df)
df
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
plot(df, color = "red", add = TRUE)
over(vp, df)
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp, graticule = st_crs(4326), key.pos = 1)
res <- over(vp, df)
res
res[1]
res[1,1]
res <- over(vp, df,  returnList = TRUE)
res
res[1]
len(res[1])
length(res[1])
dim(res[1])
res[1]
vp[df]
df[vp]
View(df)
result <- data.frame(df,grid=over(df,vp))
View(result)
over(df, vp)
View(result)
View(GeoAccidentalidad)
grid  <- GridTopology(cellcentre.offset= c(40.41,-3.68), cellsize = c(2,2), cells.dim = c(5,5))
sg    <- SpatialGrid(grid)
plot(sg)
plot(df)
plot(sg)
grid  <- GridTopology(cellcentre.offset= c(40.41,-3.68), cellsize = c(0.03,0.03), cells.dim = c(5,5))
sg    <- SpatialGrid(grid)
plot(sg)
plot(df)
plot(sg, df)
proj4string(sg)
proj4string(sg) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(sg)
plot(df)
proj4string(df)
proj4string(sg)
over(sg, df)
grid  <- GridTopology(cellcentre.offset= c(-3.68,40.41), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada cela, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
proj4string(sg)
plot(sg)
proj4string(sg) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(df)
over(sg, df)
plot(vp)
plot(df)
plot(vp)
plot(df, color = "red", add = TRUE)
plot(sg)
plot(df, color = "red", add = TRUE)
over(sg, df)
over(df, sg)
poly  <- as.SpatialPolygons.GridTopology(grid)
plot(poly)
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
over(poly, df)
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.65,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.63,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.60,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
over(df, poly)
df <- randomCenters
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 20, type = "random")
df <- randomCenters
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, poly))
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(15,15)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
df <- data.frame(GeoAccidentalidad$lon, GeoAccidentalidad$lat)
df <- unique(df[1:500,]) #Esto es porque se repite cada accidente por persona creo
colnames(df) <- c("lon", "lat")
coordinates(df) <- ~ lon + lat
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, vp))
df <- spsample(df, 10, type = "random")
plot(vp)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, vp))
library("lattice")
spplot(sp_grd, "id",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(poi, cex=1.5)
panel.text(...)
}
ç
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(3,3)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
library("rgdal")
install.packages("rgdal")
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
ssplot(poly)
library(sp)
ssplot(poly)
spplot(poly)
spplot(vp)
spplot(VP, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp,
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp,
panel = function(...) {
panel.gridplot(..., border="black")
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp)
data.frame(df, grid = over(df, vp))
plot(vp)
plot(df, color = "red", add = TRUE)
load("~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Cleaned_data/GeoAccidentalidad.RData")
prueba <- GeoAccidentalidad[by = list(FECHA)]
library(data.table)
prueba <- GeoAccidentalidad[by = list(FECHA, `RANGO HORARIO`, lon, lat)]
View(prueba)
prueba <- GeoAccidentalidad[,by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[,,by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[., by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[,.N , by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- na.omit(prueba)
View(prueba)
prueba[,.N, by = FECHA]
prueba[,.N, by = `RANGO HORARIO`]
prueba[,.N, by = FECHA]
p <- prueba[,.N, by = FECHA]
View(p)
8*365
9*365
GeoAccidentalidad[, .N, by = FECHA]
prueba <- GeoAccidentalidad[,.N , by = list(FECHA, `RANGO HORARIO`, `LUGAR ACCIDENTE`, lon, lat)]
R2043_CVf_26 <- read.table("~/Descargas/R2043_CVf_26.dat", quote="\"")
View(R2043_CVf_26)
