crds = layer@coords
z = deldir(crds[,1], crds[,2])
w = tile.list(z)
polys = vector(mode='list', length=length(w))
require(sp)
for (i in seq(along=polys)) {
pcrds = cbind(w[[i]]$x, w[[i]]$y)
pcrds = rbind(pcrds, pcrds[1,])
polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i))
}
SP = SpatialPolygons(polys)
voronoi = SpatialPolygonsDataFrame(SP, data=data.frame(dummy = seq(length(SP)), row.names=sapply(slot(SP, 'polygons'),
function(x) slot(x, 'ID'))))
}
vp <- voronoipolygons(df[1:10,])
plot(vp)
df[1:10,]
vp <- voronoipolygons(df)
plot(vp)
df[1:10,]
df <- unique(df)
vp <- voronoipolygons(df[1:10,])
plot(vp)
class(df)
proj4string(india)
proj4string(df)
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
View(df)
proj4string(df)
df <- data.frame(GeoAccidentalidad$lat, GeoAccidentalidad$lon)
df <- unique(df[1:1000,]
)
colnames(df) <- c("lon", "lat")
coordinates(df) <- ~ lon + lat
View(df)
View(df)
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
View(df)
View(df)
vp <- voronoipolygons(df[1:10,])
plot(vp)
vp <- voronoipolygons(GeoAccidentalidad)
plot(df)
over(vp,df)
proj4string(vp)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
proj4string(vp)
over(vp,df)
View(GeoAccidentalidad)
df
random(df)
spsample(df, 5)
spsample(df, 5, type = "random")
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_voronoi.R')
plot(vp)
proj4string(vp)
over(vp, df)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
over(vp, df)
View(GeoAccidentalidad)
View(df)
df
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
plot(df, color = "red", add = TRUE)
over(vp, df)
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp, graticule = st_crs(4326), key.pos = 1)
res <- over(vp, df)
res
res[1]
res[1,1]
res <- over(vp, df,  returnList = TRUE)
res
res[1]
len(res[1])
length(res[1])
dim(res[1])
res[1]
vp[df]
df[vp]
View(df)
result <- data.frame(df,grid=over(df,vp))
View(result)
over(df, vp)
View(result)
View(GeoAccidentalidad)
grid  <- GridTopology(cellcentre.offset= c(40.41,-3.68), cellsize = c(2,2), cells.dim = c(5,5))
sg    <- SpatialGrid(grid)
plot(sg)
plot(df)
plot(sg)
grid  <- GridTopology(cellcentre.offset= c(40.41,-3.68), cellsize = c(0.03,0.03), cells.dim = c(5,5))
sg    <- SpatialGrid(grid)
plot(sg)
plot(df)
plot(sg, df)
proj4string(sg)
proj4string(sg) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(sg)
plot(df)
proj4string(df)
proj4string(sg)
over(sg, df)
grid  <- GridTopology(cellcentre.offset= c(-3.68,40.41), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada cela, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
proj4string(sg)
plot(sg)
proj4string(sg) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(df)
over(sg, df)
plot(vp)
plot(df)
plot(vp)
plot(df, color = "red", add = TRUE)
plot(sg)
plot(df, color = "red", add = TRUE)
over(sg, df)
over(df, sg)
poly  <- as.SpatialPolygons.GridTopology(grid)
plot(poly)
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
over(poly, df)
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.65,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.63,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
grid  <- GridTopology(cellcentre.offset= c(-3.60,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
over(df, poly)
df <- randomCenters
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
over(poly, df)
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 20, type = "random")
df <- randomCenters
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, poly))
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(15,15)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
df <- data.frame(GeoAccidentalidad$lon, GeoAccidentalidad$lat)
df <- unique(df[1:500,]) #Esto es porque se repite cada accidente por persona creo
colnames(df) <- c("lon", "lat")
coordinates(df) <- ~ lon + lat
proj4string(df) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
randomCenters <- spsample(df, 10, type = "random")
vp <- voronoipolygons(randomCenters)
proj4string(vp) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(vp)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, vp))
df <- spsample(df, 10, type = "random")
plot(vp)
plot(df, color = "red", add = TRUE)
data.frame(df, grid = over(df, vp))
library("lattice")
spplot(sp_grd, "id",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(poi, cex=1.5)
panel.text(...)
}
ç
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(5,5)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(3,3)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
library("rgdal")
install.packages("rgdal")
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(shp)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(poly, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
ssplot(poly)
library(sp)
ssplot(poly)
spplot(poly)
spplot(vp)
spplot(VP, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp, "grid",
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp,
panel = function(...) {
panel.gridplot(..., border="black")
sp.polygons(df)
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp,
panel = function(...) {
panel.gridplot(..., border="black")
sp.points(df, cex=1.5)
panel.text(...)
})
spplot(vp)
data.frame(df, grid = over(df, vp))
plot(vp)
plot(df, color = "red", add = TRUE)
load("~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Cleaned_data/GeoAccidentalidad.RData")
prueba <- GeoAccidentalidad[by = list(FECHA)]
library(data.table)
prueba <- GeoAccidentalidad[by = list(FECHA, `RANGO HORARIO`, lon, lat)]
View(prueba)
prueba <- GeoAccidentalidad[,by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[,,by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[., by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- GeoAccidentalidad[,.N , by = list(FECHA, `RANGO HORARIO`, lon, lat)]
prueba <- na.omit(prueba)
View(prueba)
prueba[,.N, by = FECHA]
prueba[,.N, by = `RANGO HORARIO`]
prueba[,.N, by = FECHA]
p <- prueba[,.N, by = FECHA]
View(p)
8*365
9*365
GeoAccidentalidad[, .N, by = FECHA]
prueba <- GeoAccidentalidad[,.N , by = list(FECHA, `RANGO HORARIO`, `LUGAR ACCIDENTE`, lon, lat)]
R2043_CVf_26 <- read.table("~/Descargas/R2043_CVf_26.dat", quote="\"")
View(R2043_CVf_26)
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/diagramas_grid.R')
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
randomCenters <- spsample(df, 10, type = "random")
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(3,3)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
# En el post del grid numerado se puede ver como pasar de esta cuadrícula a un spdf si fuese necesario para un spplot o lo que fuese.
df <- randomCenters
# GRID CUADRADO:
# Si lo que buscamos es un grid normal y corriente, se puede crear así:
grid  <- GridTopology(cellcentre.offset= c(-3.7,40.39), cellsize = c(0.03,0.03), cells.dim = c(3,3)) # Centro, distancia de cada celda, y número de celdas en cada dimensión
sg    <- SpatialGrid(grid)
poly  <- as.SpatialPolygons.GridTopology(grid)
# NO OLVIDES ESTO SI QUIERES JUNTAR TODO EN LA MISMA GRÁFICA Y HACER OVER. Quizás vale con CRS("+proj=longlat") (en todos claro)
proj4string(poly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
plot(poly)
plot(df, color = "red", add = TRUE)
# Esto hace un data.frame con el grid al que pertenece cada coordenada
data.frame(df, grid = over(df, poly))
# En el post del grid numerado se puede ver como pasar de esta cuadrícula a un spdf si fuese necesario para un spplot o lo que fuese.
rm(list = ls())
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/datos_stnn.R')
View(crash)
heat <- fread("Raw_data/heat.csv")
View(heat)
cras <- crash[, FECHA := NULL]
crash <- crash[, FECHA := NULL]
View(crash)
View(crash)
save()
save(crash, "Cleaned_data/crash.csv")
save("Cleaned_data/crash.csv", crash)
save(crash, file = "Cleaned_data/crash.csv")
crash <- as.matrix(crash[, FECHA := NULL])
save(crash, file = "Cleaned_data/crash.csv")
crash <- crash[, FECHA := NULL]
source('~/Universidad/Máster en IA Avanzada/TFM/Accidentes de tráfico - Madrid/Scripts/Fase 2/datos_stnn.R')
write.csv(crash, file = "Raw_data/crash.csv")
help("write.csv")
write.csv(crash, file = "Raw_data/crash.csv", row.names = FALSE, col.names = FALSE)
write.table(crash, file = "Raw_data/crash.csv", row.names = FALSE, col.names = FALSE)
write.table(crash, file = "Raw_data/crash.csv", append = TRUE, row.names = FALSE, col.names = FALSE)
View(poly)
crash2 <- fread("Raw_data/crash.csv")
View(crash2)
write.table(crash, file = "Raw_data/crash.csv", row.names = FALSE, col.names = FALSE)
crash2 <- fread("Raw_data/crash.csv")
View(crash2)
W1 <- fread("Raw_data/heat_relations.csv")
View(W1)
install.packages("hierarchicalDS")
matrix(3,3)
matrix(3)
matrix(5,5)
matrix(nrow = 3, ncol = 3)
make_matrix = function(n_zonas){
M = matrix(nrow = n_zonas, ncol = n_zonas)
for (r in 1:n_zonas){
for (c in 1:n_zonas){
i = r*cols + c
# Two inner diagonals
if (c > 0){
M[i-1,i] = M[i,i-1] = 1
}
# Two outer diagonals
if (r > 0){
M[i-cols,i] = M[i,i-cols] = 1
}
}
}
}
W = make_matrix(5)
make_matrix = function(n_zonas){
M = matrix(nrow = n_zonas, ncol = n_zonas)
for (r in 1:n_zonas){
for (c in 1:n_zonas){
i = r*n_zonas + c
# Two inner diagonals
if (c > 0){
M[i-1,i] = M[i,i-1] = 1
}
# Two outer diagonals
if (r > 0){
M[i-n_zonas,i] = M[i,i-n_zonas] = 1
}
}
}
}
W = make_matrix(5)
make_matrix = function(n_zonas){
M = matrix(nrow = n_zonas, ncol = n_zonas)
for (r in 1:n_zonas){
for (c in 1:n_zonas){
i = r*n_zonas + c
# Two inner diagonals
if (c > 0){
M[i,i] = M[i,i] = 1
}
# Two outer diagonals
if (r > 0){
M[i-n_zonas,i] = M[i,i-n_zonas] = 1
}
}
}
}
W = make_matrix(5)
matrix(nrow = 3, ncol = 3)
matrix(nrow = 3, ncol = 3, 0)
install.packages("matlab")
# 11_ A continuación se construye la matriz de adjacencia
library(matlab)
sum(c(1,2,3))
diagVec1 = repmat((ones(n_zonas-1, 1); 0), n_zonas, 1)
diagVec1 = repmat((ones(n_zonas-1, 1), 0), n_zonas, 1)
W2 <- fread("Raw_data/crash_relations.csv")
View(W2)
write.table(W2, file = "Raw_data/crash_relations.csv", row.names = FALSE, col.names = FALSE)
